# 1.面试问题合集

## 1.lambda函数原理总结

https://blog.csdn.net/jiandabang/article/details/104543998

lambda函数原理总结

a). 编译期：在lambda函数定义的类中，编译其会生成一个静态方法，该静态方法的内容和lambda函数内容一致。

b). 运行期：程序第一次运行到lambda函数定义的地方，会生成一个内部类，并实现了lambda函数实现的函数式接口，该接口的实现方法中，调用了步骤(a)中中的静态方法。

c). 该lambda函数被调用时，程序首先进入的就是步骤(b)的内部类中的函数式接口的实现方法，然后该实现方法调用了步骤(a)中生成的静态方法。

d). lambda函数的真正实现方法是编译器生成的定义lambda函数所在类中的一个静态方法。

**扩展**：lambda函数的调用底层是用字节码指令invokeDynamic指令实现，程序第一次执行到lambda函数时，会通过invokeDynamic指令调用bootstrapMethod找到目标方法（也就是步骤b的内部类中函数式接口实现方法），后续程序再次执行到该lambda函数时，不再需要调用bootstrapMethod，而是直接进入目标方法。

invokeDynamic指令，简单理解为，在程序运行期生成一个实现lambda函数式接口的实现类，并创建该类的实例，程序第一次拿到该实例后，就不再需要调用invokeDynamic指令来获得该实例。



**2.使用场景：**

1.列表迭代

2.map的映射

```java
 numbers.stream().map(x -> x * 2).collect(Collectors.toList());
```

3.Predicate 接口

4.替代Runnable

## 2.系统CPU是4核8G  I/O密集型怎么设置整个线程池核心的数量

![img](https://img-blog.csdnimg.cn/20210430162419641.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RvX3JlYWw=,size_16,color_FFFFFF,t_70)

CPU密集型：CPU密集型也叫计算密集型，指的是系统的硬盘、内存性能相对CPU要好很多。CPU大部分都在计算中

I/O密集型：IO密集型指的是系统的CPU性能相对硬盘、内存要好很多，此时，系统运作，大部分的状况是CPU在等I/O (硬盘/内存) 的读/写操作，此时CPU Loading并不高

## **3.怎么动态的扩容分库分表**

1.停机部署

相当于 直接使用中间件 分配策略 然后进行数据迁移。

2.不停机部署

1. 通过在写原有的数据库的同时也写一份数据到我们的新的库表中。
2. 同样写一个后台迁移数据的程序，将我们的旧库的数据通过我们的数据库中间件迁移到新的多库表中。
3. 在迁移的过程中，每次插入数据的时候，还需要检测数据的更新情况。比如，如果新的表中没有当前的数据，则直接新增；如果新表有数据并没有我们要迁移的数据新的话，我们就更新为当前数据，只能允许新的数据覆盖旧的数据。
4. 经过一轮之后，也就是假如旧表中1000万条旧数据迁移完之后，我们就需要进行校验，校验两边数据是否是一模一样的。
5. 这样反复的跑了几天之后，就数据库和新的数据库肯定是会一模一样的，最后观察下数据正常了，就可以停掉旧库的写入动作了。

## 4.如何实现一个自定义类加载器。怎么打破双亲委派？

1.为什么要自定义加载器、

1、存放在自定义路径上的类，需要通过自定义类加载器去加载。【注意：AppClassLoader加载classpath下的类】
2、类不一定从文件中加载，也可能从网络中的流中加载，这就需要自定义加载器去实现加密解密。
3、可以定义类的实现机制，实现类的热部署

2.怎么自定义类加载器

1、继承ClassLoader

2、重写findClass，在findClass里获取类的字节码，并调用ClassLoader中的defineClass方法来加载类，获取class对象。
注意：如果要打破双亲委派机制，需要重写loadClass方法。

**双亲委派的好处？**

1.Java程序的稳定运行，

2.可以避免类的重复加载（JVM 区分不同类的方式不仅仅根据类名，相同的类文件被不同的类加载器加载产生的是两个不同的类），

3.也保证了 Java 的核心 API 不被篡改。



**列举一些你知道的打破双亲委派机制的例子，为什么要打破？**

Tomcat，应用的类加载器优先自行加载应用目录下的 class，并不是先委派给父加载器，加载不了才委派给父加载器。
tomcat之所以造了一堆自己的classloader，大致是出于下面三类目的：
1.对于各个  webapp 中的  class 和  lib ，需要相互隔离，不能出现一个应用中加载的类库会影响另一个应用的情况，而对于许多应用，需要有共享的lib以便不浪费资源。
2.与  jvm 一样的安全性问题。使用单独的  classloader 去装载  tomcat 自身的类库，以免其他恶意或无意的破坏；
3.热部署。





## 5.ClassNotFoundException

ClassNotFoundException 表示类找不到异常，是一种 Exception，通常发生在载入阶段，当开发者主动调用 、或 动态加载指定类时候，类加载器就会去 classpath 下寻找类，如果找不到就会抛出此错误。

还有另外一种情况是当一个类已经被某个类加载器加载到内存中，另外一个类加载器试图去加载时也会发生错误。





## 6.java基础

**1.抽象类和接口的区别**

　　1）抽象类可以提供成员方法的实现细节，而接口中只能存在抽象方法；

　　2）抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是常量；

　　3）接口中不能含有静态代码块以及静态方法，而抽象类可以有静态代码块和静态方法；

　　4）一个类只能继承一个抽象类，而一个类却可以实现多个接口。

​		5）抽象类中的方法可以被 static 修饰，接口中的方法不可以被 static 修饰 ---> jdk 1.8  可以接口可以有static修饰的方法。

 **2.static和final**

​	1)static

​        1.static可以用来修饰类的成员方法、类的成员变量，另外可以编写static代码块来优化程序性能。

​	  static  修饰方法：静态方法。不依赖于对象就可以访问，可以直接类名.静态方法访问。静态方法不可以访问对      象的非静态方法和非静态变量。
​       static  变量：静态变量被所有的对象所共享，在内存中只有一个副本，存在方法区中，当且仅当在类初次加载时会被初始化。
​       static  静态代码块：在类被初次加载时执行，且执行一次，通常将只需要进行一次的初始化操作都放在 static 代码块中进行。

​	2）final

1. 被final声明的方法：这个方法不可以被子类重写

2. 被final声明的类：这个类不能被继承

3. 被final声明的变量：引用不能改变，常和static关键字一起使用作为常量

好处：

1. final关键字提高了性能。JVM和Java应用都会缓存final变量。
2. final变量可以安全的在多线程环境下进行共享，而不需要额外的同步开销。
3. 使用final关键字，JVM会对方法、变量及类进行优化。（1.在构造函数对一个final域的写入，与之后把这个被构造对象的引用赋值给一个引用变量，这两个是不能进行重排序的
4. 2.初次读包含final域的对象的引用，与之后读不能进行重排序

**3.异常：**

<img src="C:\Users\95124\AppData\Roaming\Typora\typora-user-images\image-20210701111640407.png" alt="image-20210701111640407" style="zoom:50%;" />

​		Error 类是指 java 运行时系统的内部错误和资源耗尽错误。应用程序不会抛出该类对象。如果出现了这样的错误，除了告知用户，剩下的就是尽力使程序安全的终止。

​       Exception （ RuntimeException、CheckedException ）

1. 运行时异常( 免检异常)：RuntimeException 类极其子类表示 JVM 在运行期间可能出现的错误。
   比 如 说 试 图 使 用 空 值 对 象 的 引 用 （ NullPointerException ）、 数 组 下 标 越 界
   （ArrayIndexOutBoundException）。此类异常属于不可查异常，一般是由 程序逻辑错误引起的，在。 程 序 中 可 以 选 择 捕 获 处 理 ， 也 可 以 不 处 理 。 ArithmeticException ， ， ClassCastException ， ，
   NumberFormatException ，IllegalArgumentException。 。
2. 编译异常( 受检异常)：Exception 中除 RuntimeException 极其子类之外的异常。如果程序中出
   现此类异常，比如说 IOException， ， 必须对该异常进行处理 ， 否则编译不通过 。

**throw和throws区别**

1. throws 用在函数上，后面跟的是异常类，可以跟多个；而 throw 用在函数内，后面跟的是异常对象。

2. throws 用来声明异常，让调用者只知道该功能可能出现的问题，可以给出预先的处理方式；throw抛出具体的问题对象，执行到throw，功能就已经结束了，跳转到调用者，并将具体的问题对象抛给调用者。也就是说 throw 语句独立存在时，下面不要定义其他语句，因为执行不到。

3. throws 表示出现异常的一种可能性，并不一定会发生这些异常；throw 则是抛出了异常，执行 throw 则一定抛出了某种异常对象。

4. 两者都是消极处理异常的方式，只是抛出或者可能抛出异常，但是不会由函数去处理异常，真正的处理异常由函数的上层调用处理。

**4.序列化**

​     序列化是指把 java 对象转换为字节序列的过程，而 java 反序列化是指把字节序列恢复为 java对象的过程。
序列化是把对象转换成有序字节流，以便在网络上传输或者保存在本地文件中。

​    反序列化：客户端从文件中或网络上获得序列化后的对象字节流后，根据字节流中所保存的对象状态及描述信息，通过反序列化重建对象。(利用序列化实现远程通信，可以在网络上传送对象的字节序列。在进程间传递对象，永久性保存对象).

**5.StringBuffer 和StringBuilder 的区别**

StringBuffer 每次获取 toString 都会直接使用缓存区的 toStringCache 值来构造一个字符串。

而 StringBuilder 则每次都需要复制一次字符数组，再构造一个字符串。

所以，缓存冲这也是对 StringBuffer 的一个优化吧，不过 StringBuffer 的这个toString 方法仍然是同步的。

StringBuffer：线程安全，StringBuilder：线程不安全。

**6.java的三大特性**

封装、继承、多态

封装：把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行封装隐藏。封装分为属性的封装和方法的封装。**核心思想就是“隐藏细节”、“数据安全”：将对象不需要让外界访问的成员变量和方法私有化，只提供符合开发者意愿的公有方法来访问这些数据和逻辑，保证了数据的安全和程序的稳定**。好处：良好的封装能减少耦合，对成员变量更精确的控制。
继承：子类可以继承父类的非私有方法和属性(默认属性和方法也不行)，达到复用代码的效果。Java 是单继承，一个类只能继承一个父类。
多态: **多态是同一个行为具有多个不同表现形式或形态的能力**。 同一消息可以根据发送对象的不同而采用多种不同的行为方式。可以用于消除类型之间的耦合关系，Spring 的核心就是多态和面向接口编程。多态的分类，编译时多态，方法的重载，运行时多态，方法的覆盖。 多态存在的条件 ： 存在继承关系，子类重写父类的方法，父类引用指向子类。
Java  里对象方法的调用是依靠类信息里的方法表实现的。
重载： 发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同，发生在编译时。
重写：发生在父子类中，方法名、参数列表必须相同，返回值小于等于父类，抛出的异常小于等于为 父类，访问修饰符大于等于父类；如果父类方法访问修饰符为 private  则子类中就不是重写。



**7.compare方法和compareTo有什么区别**

`compareTo()`来自`Comparable`接口。  比较值并返回一个int，告诉它们的值是小于，等于还是大于。

`compare()`来自`Comparator`接口。  比较两个对象的值。这被实现为的一部分`Comparator`界面，并且**典型的使用是定义实现此的一个或多个小工具类，传递给方法，例如**`**sort()**`**或使用通过排序数据结构**



**8.字符流与字节流的区别？**
1.读写的时候字节流是按字节读写，字符流按字符读写。
2.字节流适合所有类型文件的数据传输，因为计算机字节（Byte）是电脑中表示信息含义的最小单位。字符流只能够处理纯文本数据，其他类型数据不行，但是字符流处理文本要比字节流处理文本要方便。
3.在读写文件需要对内容按行处理，比如比较特定字符，处理某一行数据的时候一般会选择字符流。只是读写文件，和文件内容无关时，一般选择字节流





**7.简单介绍一下lock?**

Lock完全用Java写成，在java这个层面是无关JVM实现的。

在java.util.concurrent.locks包中有很多Lock的实现类，常用的有ReentrantLock、ReadWriteLock（实现类ReentrantReadWriteLock），其实现都依赖java.util.concurrent.AbstractQueuedSynchronizer类。

 简单说来，AbstractQueuedSynchronizer会把所有的请求线程构成一个CLH队列，当一个线程执行完毕（lock.unlock()）时会激活自己的后继节点，但正在执行的线程并不在队列中，而那些等待执行的线程全部处于阻塞状态，经过调查线程的显式阻塞是通过调用LockSupport.park()完成，而LockSupport.park()则调用sun.misc.Unsafe.park()本地方法，再进一步，HotSpot在Linux中中通过调用pthread_mutex_lock函数把线程交给系统内核进行阻塞。

8.**内部类为什么能够直接访问外部类的属性和方法**

**编译器会默认为成员内部类添加了一个隐式的指向外部类对象的引用this$0。虽然我们在定义的内部类的构造器是无参构造器，编译器还是会默认添加一个参数，该参数的类型为指向外部类对象的一个引用。**
所以，内部类可以随意的访问外部类中的方法和变量。



9.**多态的实现**

https://www.cnblogs.com/feicheninfo/p/9669137.html

 不同类的对象对同一消息作出不同的响应叫做多态 。 同一消息可以根据发送对象的不同而采用多种不同的行为方式。

java 中的方法调用有静态绑定和动态绑定之分，静态绑定指的是我们在编译期就已经确定了会执行那个方法的字节码，而动态绑定只有在运行时才能知晓。Java 中的静态方法、私有方法以及 final 修饰的方法的调用，都属于静态绑定，对于重载的实例方法的调用，也是采用静态绑定。方法调用动作会被编译成静态调用指令，该指令对应常量池中方法的符号引用。
Java 对于方法调用动态绑定的实现主要依赖于 方法表，但通过 类引用调用和接口引用调用的实现则有所不同。总体而言，当某个方法被调用时，JVM 首先要查找相应的 常量池，得到 方法的符号引用，并查找调用类的方法表以确定该 方法的直接引用，最后才真正调用该方法。以下分别对该过程中涉及到的相关部分做详细介绍。
**动态绑定**：JVM 有个方法表：记录当前类以及所有父类的可见方法字节码在内存中的直接地址。

对于类的继承 中方法重写。会根据偏移量来。 也是  首先会拿到这个对象的方法表。如果有重写 则调用这个方法

如果没有的话则需要拿到按照继承关系从下往上的基类的方法表。还是到偏移量去寻找。

Java 对于接口方法的调用是采用搜索方法表的方式，如，要在Dancer的方法表中找到dance()方法，必须搜索Dancer的整个方法表

**10.Java中final、finally、finalize的区别与用法**

**final：java中的关键字，修饰符。**
A).如果一个类被声明为final，就意味着它不能再派生出新的子类，不能作为父类被继承。因此，一个类不能同时被声明为abstract抽象类的和final的类。
B).如果将变量或者方法声明为final，可以保证它们在使用中不被改变.
　　1)被声明为final的变量必须在声明时给定初值，而在以后的引用中只能读取，不可修改。
　　2)被声明final的方法只能使用，不能重载。
**finally：java的一种异常处理机制。**
　　finally是对Java异常处理模型的最佳补充。finally结构使代码总会执行，而不管无异常发生。使用finally可以维护对象的内部状态，并可以清理非内存资源。特别是在关闭数据库连接这方面，如果程序员把数据库连接的close()方法放到finally中，就会大大降低程序出错的几率。
**finalize：Java中的一个方法名。**
Java技术使用finalize()方法在垃圾收集器将对象从内存中清除出去前，做必要的清理工作。这个方法是由垃圾收集器在确定这个对象没被引用时对这个对象调用的。它是在Object类中定义的，因此所的类都继承了它。子类覆盖finalize()方法以整理系统资源或者执行其他清理工作。finalize()方法是在垃圾收集器删除对象之前对这个对象调用的。







## 7.TCP [keep](https://www.nowcoder.com/jump/super-jump/word?word=keep) alive和HTTP [keep](https://www.nowcoder.com/jump/super-jump/word?word=keep) alive的区别？

1.在**HTTP Keep-Alive**中使用keep-alive可以改善这种状态，即在一次TCP连接中可以持续发送多份数据而不会断开连接。通过使用keep-alive机制，可以减少tcp连接建立次数，也意味着可以减少TIME_WAIT状态连接，

2.在TCP Keep-Alive中，。是保活机制。为了确定建立的TCP链接对方长时间没有数据传输。确认对方是否存活。

## 8.计算机网络为什么要分层？

1.对上一层提供服务  2.使用下层的服务

分层的好处：1.每层的功能明确，使得功能更加模块化，结构化
                        2.降低耦合性，便于开发，当某一层的功能实现改变时，不影响其它层（因为仅仅是功能的实现方式改变了，但最后还是实现的那个功能。

## 9.http协议是什么工作模式？

`http1.0`：单工。因为是短连接，客户端发起请求之后，服务端处理完请求并收到客户端的响应后即断开连接。

`http1.1`：半双工。默认开启长连接`keep-alive`，开启一个连接可发送多个请求。

`http2.0`：全双工，允许服务端主动向客户端发送数据。

1. http协议有多个版本,存在区别,截至2019.1,主流协议是http1.1
2. http1.1以下版本,http连接为短连接,tcp连接发送信息等待接受信息后断开.
3. http1.1 是半双工,建立长连接,出现多路复用,可先后发送多个http请求,不用等待回复,但是回复按顺序一个一个回复.(当前主流)
4. http2.0是全双工,一个消息发送后不用等待接受,第二个消息可以直接发送.

遗留问题：

为什么`http1.1`是基于TCP/IP(全双工)而是半双工的？

因为HTTP1.1 协议是基于 TCP 协议的，所以它使用面向连接的方式发送请求，通过 stream 二进制流的方式传
给对方。当然，到了 TCP 层，它会把二进制流变成一个的报文段发送给服务器。在发送给每个报文段的时候，都需要对方有一个回应 ACK，来保证报文可靠地到达了对方。如果对方没有收到  下层的TCP就会一直重试。

HTTP请求 都是一应一答的也就是说一个request只能有一个response。

## 10.Nginx

https://cloud.tencent.com/developer/article/1427219

1.Nginx是怎么做到高并发的处理请求的？

Nginx采用了Linux的epoll模型，epoll模型基于时间驱动机制，它可以监控多个事件是否准备完成，如果ok，那么放入epoll队列中，这个过程是异步的，worker只需要从epoll队列中循环处理就可以了。

2.Nginx中的多进程处理请求的方式？（**多线程+异步非阻塞I/0**）

首先，master进程一开始根据我们的配置，来建立需要listen的网络socket fd，然后fork出多个worker进程。其次，根据进程的特性，新建立的worker进程也和master进程一样具有相同的设置。因此，也会去监听相同ip端口的套接字（socket fd）。然后当这个时候有多个worker进程监听到事件的时候，就会去处理。那么怎么去处理多个woker处理同一个请求的情况呢？

为了保证只会有一个进程成功的处理事件，那么Nginx中实现了一个accept_mutex 类似互斥锁，只有获取到这个锁的进程，才能去注册读事件。

最后，监听成功的worker才会去读取请求，解析处理，响应数据返回给客户端，断开连接，结束。因此，一个request请求，只需要worker进程就可以完成。

这种模型 的好处就是：各个进程是独立的，当一个worker出现异常不会影响其他。此外，独立进程也会避免一些不需要的锁操作，这样子会提高效率。

## 11.协程与线程的区别？

线程和进程都是同步机制，而协程是异步机制。
线程是抢占式，而协程是非抢占式的。

协程是一种用户态的轻量级线程， 协程的调度完全由用户控制 。 协程拥有自己的寄存器上下文和栈。
协程调度切换时， 将寄存器上下文和栈保存到其他地方。在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则 基本没有内核切换的开销 ，全程可以不加锁的访问全  局变量 ， 所以上下文的切换非常快。进程线程都是同步机制，而协程则是异步。协程不需要多线程的锁机制。

## 12.JDK动态代理的底层实现原理？

https://www.cnblogs.com/zuidongfeng/p/8735241.html

1、为接口创建代理类的字节码文件

2、使用ClassLoader将字节码文件加载到JVM

3、创建代理类实例对象，执行对象的目标方法

动态代理涉及到的主要类：

java.lang.reflect.Proxy【动态的类】
java.lang.reflect.InvocationHandler
java.lang.reflect.WeakCache【缓存】
sun.misc.ProxyGenerator

1、代理类继承了Proxy类并且实现了要代理的接口，由于java不支持多继承，所以JDK动态代理不能代理类

2、重写了equals、hashCode、toString

3、有一个静态代码块，通过反射或者代理类的所有方法

4、通过invoke执行代理类中的目标方法doSomething

## 13.Out of Memory

1.程序计数器是唯一一个在 Java 虚拟机规范中没有规定任何 oom 情况的区域。
2.在 java 虚拟机规范中，对于 java 虚拟机栈，规定了 2 中异常，1）若线程请求的栈深度>虚拟机所允许的深度，则抛出 Stack Overflowerror 异常 2）若虚拟机可以动态扩展，若扩展时无法申请到足够的内存空间，则抛出 oom 异常。
3.java 虚拟机栈为执行 java 方法，本地方法栈为虚拟机使用 native 方法服务，本地方法栈也会抛出 Stack Overflowerror 和 oom。
4.Java 堆可以处于物理上连续的内存空间，只要逻辑上是连续的即可。可固定，可扩展。若堆中没有内存完成实例分配，并且堆也无法再扩展，则会抛出 oom。
5.直接内存不是运行时数据区的一部分。

**排查 OOM 的方法：**
增加两个参数 -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/tmp/heapdump.hprof，当 OOM 发生时自动 dump 堆内存信息到指定目录；
同时 jstat 查看监控 JVM 的内存和 GC 情况，先观察问题大概出在什么区域；
使用 MAT 工具载入到 dump 文件，分析大对象的占用情况，比如 HashMap 做缓存未清理，时间长了就会内存溢出，可以把改为弱引用 。

## 14.Minor GC 和 Full GC 有什么不同呢？

Minor GC：只收集新生代的GC。
Full GC: 收集整个堆，包括 新生代，老年代，永久代(在 JDK 1.8及以后，永久代被移除，换为metaspace 元空间)等所有部分的模式。

**Minor GC触发条件**：当Eden区满时，触发Minor GC。
**Full GC触发条件**：

1.通过Minor GC后进入老年代的平均大小大于老年代的可用内存。如果发现统计数据说之前MinorGC的平均晋升大小比目前old gen剩余的空间大，则不会触发Minor GC而是转为触发full GC。
2.老年代空间不够分配新的内存（或永久代空间不足，但只是JDK1.7有的，这也是用元空间来取代永久代的原因，可以减少Full GC的频率，减少GC负担，提升其效率）。
3.由Eden区、From Space区向To Space区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小。
4.调用System.gc时，系统建议执行Full GC，但是不必然执行。

5.没有足够的连续空间分配给大对象

## 15.JVM的内存模型？

内存空间。 方法区 栈等……

**【一句话解释清楚】Java 内存模型描述**的是多线程对共享内存修改后彼此之间的可见性，另外，还确保正确同步的Java 代码可以在不同体系结构的处理器上正确运行。

1. 描述多线程环境中线程与内存的关系
2. Java内存模型定义了程序中各个变量的访问规则，即虚拟机将变量存储到内存和从内存取出变量的底层细节。
3. 这里的变量可以理解为堆和方法区的，不包括线程私有的栈。
4. 解决了多线程之间共享变量的可见性以及如何在需要的时候对共享变量进行同步。
5. 用来屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。

可以作为root节点的 有下面类型：

  		虚拟机栈(栈帧中的本地变量表)中引用的对象
          本地方法栈(Native 方法)中引用的对象
          方法区中类静态属性引用的对象
          方法区中常量引用的对象
          所有被同步锁持有的对象

## 16.JVM调优命令

**jps**：JVM Process Status Tool,显示指定系统内所有的HotSpot虚拟机进程。
**jstat**：jstat(JVM statistics Monitoring)是用于监视虚拟机运行时状态信息的命令，它可以显示出虚
拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据。
**jmap**：jmap(JVM Memory Map)命令用于生成heap dump文件，如果不使用这个命令，还阔以使用-XX:+HeapDumpOnOutOfMemoryError参数来让虚拟机出现OOM的时候·自动生成dump文件。
**jhat**：jhat(JVM Heap Analysis Tool)命令是与jmap搭配使用，用来分析jmap生成的dump，jhat内置了一个微型的HTTP/HTML服务器，生成dump的分析结果后，可以在浏览器中查看。
**jstack**：jstack用于生成java虚拟机当前时刻的线程快照。jstack来查看各个线程的调用堆栈，就可以知道没有响应的线程到底在后台做什么事情，或者等待什么资源。

还有一些常见的参数 -xms -xmx[最大堆 最小堆的大小] .**-XX:NewRatio**=4 设置老年代和新生代 **-XX:SurvivorRatio=8** 



## 17.java中多线程执行时，为何调用的是start()方法而不是run()方法

1.调用start()方法，只是变成了就绪状态【可运行的】。需要等待CPU的是时间片 才能运行。

1.当你调用 start()方法时你将创建新的线程，并且执行在 run()方法里的代 码。但是如果你直接调用 run()方法，它不会创建新的线程也不会执行调用线程的代码，**只会把 run 方法当作普通方法去执行。**

2.当调用start()方法的时候。真正创建线程的的时候start0()这个方法【本地方法】真正创建线程是JVM根据把不同的操作系统来创建线程的，。



## 18.快速排序什么情况下最坏？该怎么解决?

**快速排序**：先选定一个基准元素，按照这个基准元素将数组划分，再在被划分的数组上重复上过程，最后可以得到排序结果。

最坏的情况就是每次  选取的基准值都是**最大值 或者最小值**。这样类似于插入排序了

解决办法：

1. 选取元素的随机性，这样导致每次知道最大值或者最小的概率小。但是还是可能发生。
2. 求序列的中值，选取中值作为主元素【选取中值的复杂度是O（N）】
3. 没有中值就找离中值最近的元素。



## 19.cpu缓存一致性怎么保证

https://blog.csdn.net/xiaowenmu1/article/details/89705740



## 20.ARP协议工作原理？ARP攻击？如何解决？

https://www.cnblogs.com/csguo/p/7527303.html[ARP原理]

https://www.cnblogs.com/csguo/p/7527073.html【ARP攻击】

https://www.cnblogs.com/csguo/p/7527582.html【防御】

## 21.孤儿进程和僵尸进程，守护进程？

我们知道在unix/linux中，正常情况下，子进程是通过父进程创建的，子进程在创建新的进程。子进程的结束和父进程的运行是一个异步过程,即父进程永远无法预测子进程 到底什么时候结束。 当一个 进程完成它的工作终止之后，它的父进程需要调用wait()或者waitpid()系统调用取得子进程的终止状态。

　　**孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。**

　　**僵尸进程：一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程。**

僵尸进程的危害：

**如果父进程不调用wait / waitpid的话，** **那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵死进程，将因为没有可用的进程号而导致系统不能产生新的进程. 此即为僵尸进程的危害，应当避免。**

解决办法：

子进程退出时向父进程发送SIGCHILD信号，父进程处理SIGCHILD信号。在信号处理函数中调用wait进行处理僵尸进程

**怎么创建守护进程？**

答：守护进程是后台运行的、系统启动是就存在的、不予任何终端关联的，用于处理一些系统级别任务的特殊进程。

怎么创建守护线程？

<img src="https://img-blog.csdn.net/20161209165658384" alt="img" style="zoom:67%;" />

守护线程一般要在root权限下才能运行。



## 22.复制粘贴的功能是怎么实现的?

操作系统中会有一块地方，称作剪贴板（clipboard），专门用来处理复制粘贴。
不同系统的细节可能会不同，但大致上是这样的：

- 复制文本时，会把所复制的文本克隆一份到剪贴板里面。粘贴文本时，再将剪贴板里的文本克隆到所粘贴应用程序之中；

- - 复制文本时会保留其样式（比如在 Office 软件中复制，也会存储字体、字号等等信息，复制到剪贴板的实质上是一种「标记语言」）。但粘贴时若应用程序（比如记事本）不支持这些样式，则会去掉样式；
  - 复制图片、混合富文本时，也是同样先克隆到剪贴板里。

- 复制文件时，系统只会把文件的**路径**复制到剪贴板，等到粘贴时再**分情况处理**：

- - 同一分区下，粘贴（或剪切）文件，都不会真正在存储设备里直接克隆、挪动，而是更改此文件的路径（path）属性。当然这与不同文件系统的具体实现有关；

  - - （这也就是为什么，「复制 → 删除复制源文件 → 粘贴」这个操作会在大部分系统中失效了）

  - 不同分区下，粘贴（或剪切）文件，会重新开辟空间，然后克隆文件；







# 2.算法题和智力题

https://blog.csdn.net/Stu_YangPeng/article/details/114026077?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-0&spm=1001.2101.3001.4242

### 1.高楼扔鸡蛋

```java
动态规划
题目不是给你 K 鸡蛋，N 层楼，让你求最坏情况下最少的测试次数 m 吗？while 循环结束的条件是 dp[K][m] == N，也就是给你 K 个鸡蛋，测试 m 次，最坏情况下最多能测试 N 层楼。
    dp[k][m] = dp[k][m - 1] + dp[k - 1][m - 1] + 1

dp[k][m - 1] 就是楼上的楼层数，因为鸡蛋个数 k 不变，也就是鸡蛋没碎，扔鸡蛋次数 m 减一；
dp[k - 1][m - 1] 就是楼下的楼层数，因为鸡蛋个数 k 减一，也就是鸡蛋碎了，同时扔鸡蛋次数 m 减一。

```

100 层楼，只有两个鸡蛋，找出鸡蛋会在哪一层楼被摔碎 【14层】

dp(a,b)表示 a 块石头扔 b 次，共能测出多少层楼。dp(x,1)=1，表示扔一次就能测一个楼。dp(x,y) =
dp(x,y-1)+dp(x-1,y-1)+1 就是状态装换方程

2.数组值为1-n，各出现一次，先加入x（x也是1-n的范围），找出x 

3.给定n，计算15n，不用+*/，想了好久最后根据提示做出来了，n<<4-n 

4.给定字符数组chars，将其右移n位，空间复杂度最低，先整体反转，再反转0~n对应的字符串，和n+1~len-1对应的字符

```java
  public String LeftRotateString(String str,int n) {
        if ( str == null || str.length() == 0 ||n < 0 )
            return "";
        char[] chas = str.toCharArray();
        int len = chas.length;
        swap(chas,0,len-1);
        n = n % len;
        swap(chas,0,len-n-1);
        swap(chas,len-n,len-1);
        return String.valueOf(chas);
    }
    public void swap(char[] chars,int start, int end){
        char temp;
        while (start < end){
            temp = chars[start];
            chars[start] = chars[end];
            chars[end] = temp;
            start++;
            end--;
        }
    }
```

### 2.给十桶乒乓球(每桶中乒乓球数量无限),有一个桶的球重 9g,其余桶均为 10g。找到 9g 的那桶要测几次.

将10个箱子按1-10分别编号,然后从1号箱里拿一个小球,2号箱拿两个球,以此类推,10号箱拿10个球出来,这样就有1+2+···+10=55个球,如果全是10克重的,则应该有550克,比如称出来是547克,那么就说明这55个球中有3个是次品...

### 3.给一个很大的 log file, 形式是 user id, login time, logout time, 如何找到峰值



### 4. 25匹马，5个跑道，每次只能5匹马跑，问最少几次得到跑的最快的3匹马





# 3.Linux常用的命令

1.top：查看CPU或内存使用

2.scp:两台服务器之间拷贝文件

3.df -h 查看每个目录磁盘占有的整体情况



# 4.设计模式常用的应用场景

一般的设计原则 是  对扩展开放 对修改关闭。【比如spring容器初始化的过程中】

分为 **创建型模式**【就是怎么创建对象】， **结构型模式**【描述如何将 类或对象按某种布局组成更大的结构】 和**行为型模式**【用于描述类和对象之间怎么协同共同完成】。

**1.单例模式**

 一个类只允许创建一个对象（或者叫实例），那这个类就是一个单例类，这种设计模式就叫作单例模式。单例有几种经典的实现方式，它们分别是：饿汉式、懒汉式、双重检测、静态内部类、枚举。

需要会**写饿汉式和懒汉式和双重检测**

1、饿汉式是线程安全的,在类创建的同时就已经创建好一个静态的对象供系统使用,以后不在改变。

 2.懒汉式如果在创建实例对象时不加上synchronized则会导致对对象的访问不是线程安全的。懒汉式在需要的时候采取创建。

```java
//饿汉式
class  Singleton{//静态变量  也可以用静态代码快
    private Singleton(){   }
    private  final  static  Singleton instance=new Singleton();
    public  static  Singleton getInstance(){
        return instance;
    }
}
//懒汉式  线程不安全  如果是线程安全 在方法上加上 synchronized
class  Singleton
{
    private  static  Singleton singleton;
//    防止外部NEW 内部能new
    private Singleton(){ }
    // 线程不安全
    public  static  Singleton getInstance(){
        if (singleton==null){
            singleton=new Singleton(); }
        return singleton;
    }
}
//双重锁
class  Singleton
 {
    private  static volatile Singleton singleton;
//    防止外部NEW 内部能new
    private Singleton(){   }
    // 双重判断
    public  static  synchronized Singleton getInstance(){
        if (singleton==null){
            synchronized(Singleton.class){
                if (singleton==null){
                singleton=new Singleton(); }}
        }
        return singleton;
    }
}

```

**2.工厂模式**

简单工厂、工厂方法、抽象工厂

定义一个创建产品对象的工厂接口，将产品对象的实际创建工作推迟到具体工厂实现类中。可以随时增加新的具体产品类和对应的具体工厂类。

**3.原型模式**

如果对象的创建成本比较大，而同一个类的不同对象之间差别不大（大部分字段都相同），在这种情况下，我们可以利用对已有对象（原型）进行复制（或者叫拷贝）的方式，来创建新对象。

浅拷贝：只会复制对象中基本数据类型数据和引用对象的内存地址，不会递归地复制引用对象。

深拷贝：而深拷贝则不同，它会将原对象里的引用也新创建一个。

**4.装饰模式**

指在不改变现有对象结构的情况下， 动态地给该对象增加一些职责（即增加其额外功能）的模式，它属于对象结构型模式。

**5.适配器（Adapter ）模式**

适配器（Adapter ）模式：将一个类的接口转换成客户希望的另外一个接口，使得原本由于 接口不兼容而不能一起工作的那些类能一起工作。

**6.观测者模式**

多个对象间存在一对多关系，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其他对象的行为。

观察者模式将观察者和被观察者代码解耦。可以提高代码的执行效率

**7.责任链模式**

 把请求从链中的一个对象传到下一个对象，直到请求被响应为止。通过这种方式去除对象之间的耦合。【通常用来实现过滤器，拦截器功能那个】

**8.模板模式**

模板方法模式在一个方法中定义一个算法骨架，并将某些步骤推迟到子类中实现。模板方法模式可以让子类在不改变算法整体结构的情况下，重新定义算法中的某些步骤。

**UML图**

依赖关系：------ A  中引用了 B 系 的对象。关联关系 ——> 如老师教学生这类关系
聚合关系：—— 白菱形。整体和部分关系，has-a; 只不过部分可脱离整体存在，菱形的那边是整体 。
如汽车和轮子。
组合关系：—— 实体黑菱形。整体和部分的关系，部分不可脱离整体。黑菱形是整体。如头和嘴。
继承关系：—— 白三角，继承关系，老师继承人。
实现关系：------类实现了接口

